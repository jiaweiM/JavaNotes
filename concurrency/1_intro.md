# 基本概念

- [基本概念](#基本概念)
  - [进程和线程](#进程和线程)
    - [进程](#进程)
    - [线程](#线程)
  - [并发（Concurrency）和并行（Parallelism）](#并发concurrency和并行parallelism)
    - [并发](#并发)
  - [同步（synchronization）](#同步synchronization)
  - [不可变对象（Immutable object）](#不可变对象immutable-object)
  - [共享变量](#共享变量)
  - [原子性（Atomicity）](#原子性atomicity)
  - [共享内存和信息传递](#共享内存和信息传递)
  - [可见性（Visibility）](#可见性visibility)

2020-09-12, 14:43
@jiawei
***

## 进程和线程

在并发编程中，有两个基本执行单元：进程（process）和线程（thread）。在 Java 语言中，并发编程主要和线程相关。

一个电脑系统一般包括多个活动的进程和线程。即使是单核处理器也是如此，虽然任意时刻正在执行的线程只有一个。操作系统通过时间切片的方式，在进程和线程间共享单个处理器的处理时间。

在多任务处理系统中，CPU需要处理所有程序的操作，当用户来回切换它们时，需要记录这些程序执行到哪里。在操作系统中，CPU切换到另一个进程，需要先保存当前进程的状态，然后恢复另一个进程的状态，当前运行任务转为就绪（或者挂起、删除）状态，另一个被选定的就绪任务成为当前任务。**上下文切换**就是这样一个过程，它允许CPU记录并恢复各种正在运行程序的状态，使它能够完成切换操作。

> 在上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。在程序中，上下文切换保存在进程控制块（PCB）中，PCB还经常被称为“切换帧”。

对操作系统来说，一个任务就是一个进程，而在多个进程之间切换的时候，需要进行上下文切换，上下文切换比较耗费资源。于是人们考虑，能不能在一个进程中增加一些子任务，这样减少上下文切换的成本。比如我们使用 Word 时，可以同时进行打字、拼写检查、字数统计等，这些子任务之间共同使用同一个进程资源，因为它们之间的切换不需要进行上下文切换。

在同一进程内部，要同时干多件事，就需要同时运行多个子任务，我们把进程内的这些子任务称为**线程**（Thread）。

总的来说，可以把进程看作资源分配的基本单元，线程看作执行任务的基本单元，同一个进程内的线程共享资源。

对 Java 来说，一个JVM就是一个进程，而在JVM中，可以创建很多线程，多个线程之间共享JVM资源。

### 进程

进程，是一个计算机程序的运行实例，对 Java 来说，就是一个JVM 实例。它包含需要执行的指令，有自己独立的地址空间，包含完整的程序内容和数据。不同进程的地址空间相互隔离；进程拥有各种资源和状态信息，如打开的文件、子进程和信号处理等。

一般认为进程等效于程序或应用，然而实际上，一个程序可能包含许多互相合作的进程。为使不同进程间可交换资源，大多数操作系统支持进程间交流（Inter Process Communication, IPC）以交换资源。IPC 不仅支持相同系统进程间交流，还支持不同系统的进程间交流。

大多数 JVM 实现以单个进程运行，在 Java 中可以通过 `ProcessBuilder` 创建新的进程。

### 线程

线程也被称为轻量级进程。进行和线程都提供了一个执行环节，但是创建新的线程相对创建新的进程，需要的资源更少。线程是程序的执行流程，是CPU调度执行的基本单位，线程由自己的程序计数器、寄存器、堆栈和帧。同一进程中的线程拥有共同的地址空间，同时共享该进程的内存和其它资源。

在 java 编程中，并发编程主要和线程相关。在单 CPU 的情况下，一个时刻只能运行一个进程；进程在运行时，一个时刻也只能运行一个线程。进程是正在执行的程序，一个或更多的线程构成一个进程，操作系统以进程为单位运行，进程以线程为单位运行，一个进程至少包含一个主线程。

进程和线程的区别总结：

- 每个进程都有自己独立的一套变量，一个进程可以有多个线程。
- 线程是进程中执行的一个任务，一个进程中的多个线程共享数据。
- 线程间的共享数据，使得线程间的通信比进程间的通信更有效、更容易。
- 线程比进程更轻量级，创建和销毁线程的开销比进程要小得多；而进程则利于资源的管理和保护。

在 Java 中线程由 `Thread` 类表示，使用 `Thread` 有两种基本策略：

- 直接操作线程的创建、管理，在需要运行异步任务时实例化 Thread；
- 将线程管理和任务分离开，将任务交给 Executor，这部分是高级 API 部分。

## 并发（Concurrency）和并行（Parallelism）

并发和并行在概念上十分近似。

并发一般指在单处理器上运行多个任务，OS 的任务调度器快速切换任务，使得所有任务似乎在同时运行。

并行一般指多个任务在不同电脑、处理器或单处理器上的多核同时运行。

### 并发

可以同时做多件事情的软件称为并发软件，多线程为同步完成多项任务而设计。多线程不是为了提高运行效率，而是通过提高资源使用率来提高系统的效率。要提高效率，把语言写得接近机器语言，使用汇编语言显然最快。

使用多线程理论上可获得的增益性能可以通过 Amdahl's Law 计算：假设 F 为程序中不能并行执行的比例，N为处理器数目，则可获得的最大增益为 1/(F+((1-F)/N)).

**并发**表示如何处理多任务：可以一次处理一个任务（sequentially），也可以同时处理多个任务（concurrently）。例如，对单CPU，多个任务切换运行，在一个任务结束前，无法处理下一个任务。

**并行**表示如何处理单个任务：可以从头到尾将一个任务处理完，也可以将任务分成多个子任务，然后同时处理。

## 同步（synchronization）

在并发中，将同步定义为协调两个或多个任务一获得期望的记过。同步有两种：

- 控制同步（Control synchronization）：例如，一个任务依赖于另一个任务执行结束，第二个任务不能在第一个任务完成前启动。
- 数据访问同步（Data access synchronization）：两个或多个任务都能访问共享变量，但在任何时刻只能有一个任务可以访问。

**临界区**（critical section）和同步密不可分，临界区指只能同时由一个任务运行的代码段，因此该代码段访问了共享资源。**互斥**（mutual exclusion）是实现临界区的机制，实现互斥的方式有多种。

同步用于避免并发任务中可能出现的一些错误，但也给算法带来了额外开销。所以应当仔细考虑并行算法中那些不需要任务间通信的任务，即好好考虑并发算法的**粒度**（granularity）。对粗粒度（大任务，低任务间通信），同步带来的开销低，但是这样可能无法充分利用多CPU资源；对细粒度（小任务，高任务间通信），同步带来的开销会很高，并且算法的吞吐量可能会不好。

在并发系统中实现同步的机制有多种，从理论上来说，最流行的机制是：

- 信号量（Semaphore），信号量是一种控制对资源访问的机制。使用一个变量保存可访问资源的数目，两个原子操作管理变量的值。互斥锁（mutex, mutual exclusion 的缩写）是一种特殊类型的信号量，只能有两个值（资源空闲，资源占用），只有将资源设置为“资源占用”的进程才能释放它。
- 监视器（Monitor），监视器是一种互斥共享资源的机制。它包含一个互斥锁（mutex），一个条件变量和两个操作（等待条件和发出条件信号）发出条件信号后，等待它的任务之一接收到信号，继续执行。

最后和同步相关的概念是**线程安全**（thread safety）。如果使用共享数据的所有任务都受到同步机制的保护，则称对应的代码段为线程安全的。其中非阻塞比较交换（compare-and-swap, CAS）基础类型或数据是可不变（immutable）的，可以安全地在并发应用中使用。

## 不可变对象（Immutable object）

不可变对象在初始化后不能修改其可见状态（属性值），如果想修改不可变对象的值，只能重新创建一个。

不可变对象的最大优点是线程安全，可以在并发应用中随意使用，不会出现任何问题。Java 中的 String 就是一个不可变对象，在你给 `String` 对象重新分配值时，实际上是新创建了一个字符串。

## 共享变量

共享变量指多个线程都可以操作的变量。

在JVM中，Java堆和方法区是多线程共享的数据区域，即保存在堆和方法区中的变量就是 Java 中的共享变量。

- 类变量保存在方法区
- 成员变量在堆内存
- 局部变量在栈内存

所以，类变量和成员变量都属于共享变量，而局部变量是非共享变量。

## 原子性（Atomicity）

不能被其他线程打断的操作称为**原子性操作**（atomic operation）。Java 中唯一的原子操作是赋值，如 `a=5`，但 `a=b++` 不是原子操作。为了实现同步，有时候我们需要使特定的操作变为原子操作，在并发应用中，可以使用同步机制对临界区实现原子操作。

原子是世界上的最小单位，原子性由此而来，即具有不可分割性（至少从化学角度是不可分割的）。比如 `a=0`（a 非 long 和 double 类型），这个操作不可分割，所以称之为原子操作。再比如 `a++`，这个操作实际是 `a=a+1`，是可分割的，所以它不是原子操作。

**原子变量**（atomic variable）是设置和获取值为原子操作的变量。可以通过同步机制实现原子变量，也可以用CAS这种无需同步的无锁方式实现原子变量。

非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）使它变成一个原子操作。如果一个操作是原子操作，我们称它具有原子性。java 的 concurrent 包下提供了一些原子类，包括 `AtomicInteger`、`AtomicLong`、`AtomicReference` 等，这些类对特定类型的相应操作进行包装，使其操作具有原子性。

## 共享内存和信息传递

任务之间可以使用两种方法实现通信，其一是**共享内存**（shared memory），当任务在同一台电脑上使用时经常使用。不同任务在相同的内存区读写，为了避免问题，对共享内存的访问必须位于由同步机制保护的临界区（critical section）。

另一个同步机制是**信息传递**（Message passing），当任务在不同计算机上运行时经常使用。当一个任务需要和另一个任务通信，它会按照预定义协议发送消息，如果发送方在等待消息时阻塞，就是同步通信；如果发送方在发送消息后继续执行，就是异步通信。

## 可见性（Visibility）

一个线程对进程中共享的数据进行修改，该修改是否对另一个线程可见的问题，称为可见性问题。
