# 并发算法设计

五步法获得串行算法的并行版本。

1. 分析（找到可并发部分）
2. 设计（分解）
3. 实现
4. 正确性验证
5. 效率验证

- [并发算法设计](#%e5%b9%b6%e5%8f%91%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1)
  - [第一步：分析](#%e7%ac%ac%e4%b8%80%e6%ad%a5%e5%88%86%e6%9e%90)
  - [第二步：设计](#%e7%ac%ac%e4%ba%8c%e6%ad%a5%e8%ae%be%e8%ae%a1)
  - [第三步：实现](#%e7%ac%ac%e4%b8%89%e6%ad%a5%e5%ae%9e%e7%8e%b0)
  - [第四步：测试](#%e7%ac%ac%e5%9b%9b%e6%ad%a5%e6%b5%8b%e8%af%95)
  - [第五步：调参](#%e7%ac%ac%e4%ba%94%e6%ad%a5%e8%b0%83%e5%8f%82)
  - [总结](#%e6%80%bb%e7%bb%93)

实现并发算法的起点是它的串行版本。

虽然我们可以一开始就设计并发算法，不过串行算法至少有两个好处：

1. 可以使用串行算法的结果验证并行算法结果是否正确，从而辅助验证并发算法中是否存在数据争用或类似的问题。
2. 分析两种算法的吞吐量，查看并发是否确实改善了响应时间和吞吐量。

## 第一步：分析

这一步分析串行版本算法，查找其中可以并发执行的代码部分。要重点关注执行时间长和代码量大的部分，一般将这些部分改为并发版本能获得更大的性能提升。

互相独立的循环，或者不依赖于其它代码的代码段（如打开与数据库的连接、加载配置文件、初始化一些对象等互相独立的任务）是很好的并发对象。

## 第二步：设计

在明确并行化哪些代码后，就需要确定如何并行化。

更改的代码主要影响两部分：

- 代码结构
- 数据结构组织

可以采用两种方式实现该任务：

- 分解任务（Task decomposition），将代码拆分为两个或多个可以并行执行的独立任务时，就是任务分解。对需要按照顺序执行的任务，必须使用同步机制。
- 分解数据（Data decomposition），多个相同任务的实例对数据集的子集执行，称为数据分解。数据集为共享资源，如果线程需要修改数据，必须通过临界区来保护对其的访问。

另一个需要注意的是并行的粒度。

实现算法的并发版本是为了提高性能，因此你应该使用所有可用的处理器或内核。另一方面，在使用同步机制时，引入了一些需要执行的额外指令。如果将算法拆分为很多细小的任务（细粒度），则同步引入的额外指令可能会导致性能下降。如果拆分的任务数目小于内核数目（粗粒度），则无法充分利用CPU资源。另外，必须要考虑每个线程完成的工作，尤其是细粒度的情况。应用执行的总时长由所需时间很长的任务决定。因此必须把握一个平衡。

## 第三步：实现

这一步是使用编程语言实现并发算法，如果需要，使用一个多线程库。在 Java 中有专门的并发支持库。

## 第四步：测试

算法实现后，还需要测试。如果有对应的串行算法版本，则可对比两种算法的结果，以验证并行算法是否真确。

并行算法的测试和调试很困难，因此无法保证程序不同部分的执行顺序。

## 第五步：调参

最后一步是对比并发算法和串行算法的吞吐量。如果结果和预期不一致，需要检查算法啊，找到导致并发性能不佳的原因。

可测试不同参数（如粒度或任务数），以找到最佳参数。

有多种标准用来衡量并发算法的性能。其中有三个最流行：

- **Speedup**，用于对比并行和串行算法相对性能的标准：

    $Speedup=\frac{T_{sequential}}{T_{concurrent}}$

这里，$T_{sequential}$ 是串行算法的执行时间，$T_{concurrent}$ 是并行算法的执行时间。

- **Amdahl's law**，用于计算串行算法并行化预期的最大提升：

$Speedup\leq\frac{1}{(1-P)+\frac{P}{N}}$

这里，P 是可并行化代码的比例，N是用于执行算法的内核数。

例如，如果可并行代码比例为 75%，有四个内核，则最大提升为：

$Speedup\leq\frac{1}{(1-0.75)+(\frac{0.75}{4})}\leq\frac{1}{0.44}\leq2.29$

- **Gustafson-Barsis' law**，Amdahl's law 的局限性在于没有考虑输入问题，Gustafson law 表示在内核多时，可以解决数据规模更大的问题，公式如下：

    $Speedup=N-(1-P)*(N-1)$

这里,N是内核数，P是并行化代码比例，和上面同样的例子：

$Speedup=4-0.25*3=3.25$

## 总结

首先，并不是所有算法都适合并行化。性能已经很好的串行算法没有并行化的必要。

在实现并行应用时，需要考虑以下几点：

- 效率：并行算法相对串行算法应当有更好的效率。
- 简洁：实现算法，不管并行与否，都应该尽可能地简单。使其更容易实现、测试和维护，这样操作也更少。
- 可移植性：并行算法在不同平台上执行改变应当尽可能小。
- 可扩展性：如可以使用任意数目的内核。
