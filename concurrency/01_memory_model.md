# TOC
- [TOC](#toc)
- [CPU 和缓存一致性](#cpu-%e5%92%8c%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7)
- [处理器优化和指令重排](#%e5%a4%84%e7%90%86%e5%99%a8%e4%bc%98%e5%8c%96%e5%92%8c%e6%8c%87%e4%bb%a4%e9%87%8d%e6%8e%92)
- [并发编程问题](#%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e9%97%ae%e9%a2%98)
- [内存模型](#%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b)

# CPU 和缓存一致性
计算机在执行程序的时候，程序指令在CPU中执行，而执行的时候，又免不了要和数据打交道，而计算机上面的数据存放在主存当中的，即计算机的物理内存（硬盘）。随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。

为了解决该问题，人们在CPU和内存之间增加高速缓存。缓存即复制一份数据拷贝。他的特点是速度快，内存小，并且昂贵。

此时程序的执行过程就变成了：**当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，CPU 计算时可以直接从它的高速缓存读取数据或向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中**。

随着CPU能力的不断提升，一层缓存渐渐的无法满足要求，于是衍生出多级缓存。按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。

这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。

在有了多级缓存之后，程序的执行就变成了：**当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找**。


单核CPU只含有一套L1，L2，L3缓存；多核CPU的每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。

下图是一个单CPU双核的缓存结构以及公司结构的类比图：

![](images/2019-11-19-13-13-17.png)

随着计算机能力不断提升，开始支持多线程。那么问题就来了，我们来分别分析下单线程、多线程在单核CPU、多核CPU中的影响。
- 单线程。cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。
- 单核CPU，多线程。进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。
- 多核CPU，多线程。每个核都至少有一个 L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。

在CPU和主存之间增加缓存，在多线程场景下就可能存在**缓存一致性问题**，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。

缓存不一致的图示：

![](images/2019-11-19-13-21-22.png)

# 处理器优化和指令重排
上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽可能的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。

除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做指令重排。

可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。

# 并发编程问题
前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。

其实，原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。

这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：
1. 原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。
2. 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
3. 有序性即程序执行的顺序按照代码的先后顺序执行。

有没有发现，缓存一致性问题其实就是可见性问题。而处理器优化可能导致原子性问题。指令重排即会导致有序性问题。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。

# 内存模型
前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？

最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。

所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是**内存模型**。

为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了**共享内存系统中多线程程序读写操作行为的规范**。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。它解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。

内存模型解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。本文就不深入底层原理来展开介绍了，感兴趣的朋友可以自行学习。
