# 多线程问题

- [多线程问题](#%e5%a4%9a%e7%ba%bf%e7%a8%8b%e9%97%ae%e9%a2%98)
  - [简介](#%e7%ae%80%e4%bb%8b)
  - [线程干扰和数据争用（Data race）](#%e7%ba%bf%e7%a8%8b%e5%b9%b2%e6%89%b0%e5%92%8c%e6%95%b0%e6%8d%ae%e4%ba%89%e7%94%a8data-race)
  - [内存不一致错误](#%e5%86%85%e5%ad%98%e4%b8%8d%e4%b8%80%e8%87%b4%e9%94%99%e8%af%af)
  - [死锁（deadlock）](#%e6%ad%bb%e9%94%81deadlock)
  - [活锁（Livelock）](#%e6%b4%bb%e9%94%81livelock)
  - [饥饿（Resource starvation）](#%e9%a5%a5%e9%a5%bfresource-starvation)
  - [优先级反转（Priority inversion）](#%e4%bc%98%e5%85%88%e7%ba%a7%e5%8f%8d%e8%bd%acpriority-inversion)

## 简介

线程之间主要通过共享对字段和引用的访问进行通信。这种通信方式十分有效，但是可能导致两种错误：

- 线程干扰（thread interference）
- 内存不一致的错误（memory consistency errors）

而避免这两种错误的方法就是同步。

但是同步会导致线程争用（thread contention）的问题，当两个或多个线程尝试访问相同资源时会出现该问题，并使得某些线程运行缓慢，甚至挂起执行。

如饥饿（starvation）和活锁（livelock）就是线程争用导致的问题。

## 线程干扰和数据争用（Data race）

两个或多个线程在临界区域外修改共享变量值，导致**数据争用**，即不采用任何同步机制修改共享变量。

此时，应用的结果依赖于线程执行的顺序。

如下是一个简单的计数类：

```java
class Counter{
    private int c = 0;

    public void increment(){
        c++;
    }

    public void decrement(){
        c--;
    }

    public int value(){
        return c;
    }
}
```

按照设计，调用 `increment` 将 c 加 1，调用 `decrement` 将 c 减 1。然而当多个线程访问 `Counter` 对象，线程之间的干扰会使结果和预期不一致。

当不同线程作用于相同数据的操作出现交叉，就发生干扰。即线程对数据的一个操作包含多个步骤，步骤之间出现重叠。

例如，`Counter` 对 `c` 的一个简单操作实际分为多步执行，例如 `c++` 操作可以分为三步：

1. 获得 `c` 的当前值
2. 将获得的值 +1
3. 将新的值赋值给 c

`c--` 操作也是如此。

当多个线程访问 `Counter`，例如线程 A 调用 `increment`，线程 B 调用 `decrement`，`c` 的初始值为 0，步骤重叠的可能性如下：

1) 线程 A: 取回 c
2) 线程 B: 取回 c
3) 线程 A: 将取回的值 +1，结果为 1
4) 线程 B: 将取回的值 -1，结果为 -1
5) 线程 A: 将结果保存到 c，c 此时为 1
6) 线程 B: 将结果保存到 c，c 此时为 -1

线程 A, B之间的干扰使得计数不正确。线程 A 执行的结果被线程B覆盖而丢失。

这只是一种操作重叠的情形，只要是非原子操作，都可能导致该问题。这种操作的结果不可预测，很难发现。

## 内存不一致错误

不同线程查看相同数据获得不同结果的情况，称为内存不一致错误（Memory Consistency Errors）。内存不一致的原因很复杂，这里不予讨论。我们只看如何避免该情况的发生。

避免内存不一致错误的关键是理解操作的前后关系，保证一个线程写入数据对另一个线程是可见的。

假设我们初始化了一个 `int` 字段：

```java
int counter = 0;
```

该字段由两个线程 A 和 B 共享。假设线程 A 增加 `counter` 的值：

```java
counter++;
```

随后，线程 B 输出 `counter`:

```java
System.out.println(counter);
```

如果两个语句在同一个线程中执行，毫无疑问输出结果为 "1"。而在两个线程，输出可能是 "0"，因为不能保证线程 A 对 `counter` 的修改对 B 是可见的，除了程序员采用了措施保证连个语句发生的先后关系。

创建 happens-before 关系的方式有多种，其中一个就是同步。

## 死锁（deadlock）

两个或多个线程互相等待共享资源，如A 等待 B 持有的资源，B等待A持有的资源，一直阻塞称之为死锁。当以下四种情况(Coffman's conditions)同时出现，就出现死锁:

- 互斥条件(mutual exclusion)：死锁中涉及的资源是非共享的，一次只有一个线程可以获取该资源。
- 持有并等待条件(hold and wait condition)：一个线程持有一个资源的互斥锁，并且需要另一个资源的互斥锁。当该线程等待时，不释放任何资源。
- 非抢占式(No pre-emption)：只能由持有资源的线程释放该资源。
- 循环等待(Circular wait)：线程 1 需要线程 2 持有的资源，线程 2 需要线程3持有的资源…线程 n 需要线程1持有的资源。

避免死锁的方式：

- 忽略(Ignore them): 这是最常用的方法。如果出现死锁，程序终止，重新运行。
- 检测(Detection): 系统有一个特殊的线程专门检查系统状态是否发生死锁。如果检查到死锁，采取对应措施，如停止其中一个任务，或强制释放资源。
- 预防(prevention): 要预防死锁，则需要预防 Coffman's conditions 中的一个或多个。
- 避免(avoidance): 如果在执行前知道任务要使用的资源，则可以避免死锁。在线程执行前，分析系统空闲的资源以及线程执行所需的资源，以决定是否开始执行线程。

## 活锁（Livelock）

当两个线程总是因为对方状态的改变而改变，导致它们处于状态更高循环，无法继续执行，称之为**活锁**。

例如你有两个任务 Task 1 和 Task 2，连个都需要两个资源： Resource 1 和 Resource 2。假设 Task 1 持有 Resource 1的互斥锁，Task 2持有 Resource 2 的互斥锁，两个任务都无法获得对方资源，它们释放资源重新循环，即 Task 1释放 Resource 1 锁定 Resource 2，Task 2释放 Resource 2 锁定 Resource 1，这种情况可以无限循环下去，因此任务永远不会结束。

## 饥饿（Resource starvation）

当一个任务无法获得对共享资源的访问而暂停运行，称之为**饥饿**。

当多个任务同时等待一个资源，系统需要选择一个任务获得该资源并执行。如果系统选择任务的算法不好，会导致线程长时间等待。当共享资源被需要长时间运行的线程占用时，会出现这种情况。

公平性(fairness) 是解决该问题的方法。所有的任务都有机会持有资源，不过公平实现算法本身也有开销。

## 优先级反转（Priority inversion）

**优先级反转**(priority inversion)，当低优先级的任务持有的资源，高优先级任务也需要，就发生的优先级反转，此时低优先级的任务比高优先级任务先执行完。
