# 异常处理

- [异常处理](#异常处理)
  - [简介](#简介)
  - [异常类型](#异常类型)

## 简介

异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。
当异常情况发生，一个代表该异常的对象被创建并且在导致该错误的方法中被引发(throw)。该方法可以选择自己处理异常或传递该异常。两种情况下，该异常被捕获并处理。异常可能是由java运行时系统产生，或者是由你的手工代码产生。被java引发的异常与违反与语言规范或超出java执行时环境限制的基本错误有关。

java异常处理通过5个关键字控制：try, catch, throw, throws和finally。

程序声明中你想要的异常处理监控包含在一个try块中。如果try块中发生异常，它被抛出。你的代码可以捕捉这个异常（用catch）并且用某种合理的方法处理异常。系统产生的异常被java运行时系统自动引发。手动引发一个异常，用关键字throw。任何被引发方法的异常都必须通过throws子句定义。任何在方法返回钱绝对被执行的代码放置在finally块中。

## 异常类型

所有异常类型都是内置类 `Throwable` 的子类。下面分为两个分支：

- Exception,该类用于用户编程可能捕捉的异常情况，它也是可以用来创建自己用户异常类型子类的类。Exception包含两个子类RuntimeException和其他异常。划分两个分支的规则是：由程序错误导致的异常属于RuntimeException；而程序本身没有问题，但由于像I/O错误这类问题导致异常属于其他异常。

派生于RuntimeException的异常包含下面几种情况：
错误的类型转换；
数组访问越界；
访问空指针；
不是派生于RuntimeException的异常包括：
试图在文件尾部后面读取数据；
试图打开一个错误格式的URL；
试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在。
“如果出现RuntimeException异常，那么就一定是你的问题”~应该通过检测数组下标是否越界来避免ArrayIndexOutOfBoundsException异常；用过在使用变量之前检测是否为空来杜绝NullPointerException异常的发生。

Error,Error定义了在通常情况下不希望被程序捕获的异常，描述了java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象，如果出现了这样的内部错误，除了通告给用户，并尽力使程序安全地终止之外，再也无能为力了。这种情况很少出现。堆栈溢出是这种错误的一例。

声明已检查异常
一个方法不仅需要告诉编译器将要返回什么值，还有告诉编译器有可能发生什么错误。在自己编写方法时，不必将所有可能错误的异常都进行声明。至于什么时候需要在方法中用throws子句声明异常，什么异常必须使用throws子句声明，需要记住在遇到下面四种情况时应该抛出异常：
1.调用一个抛出已检测异常的方法。
2.程序运行过程中发现错误，并且利用throw语句抛出一个已检测异常。
3.程序出现错误。
4.java虚拟机和运行时库出现的内部异常。
如果出现前两种情况之一，则必须告诉调用这个方法的程序员有可能抛出异常。因为任何一个抛出异常的方法都有可能是一个死亡陷阱。如果没有处理器捕获这个异常，当前执行的线程就会结束。

try和catch
为防止和处理一个运行时错误，只需要把你所要监控的代码放进一个try块就可以了。紧跟着try块的，包括一个说明你希望捕获的错误类型的catch子句。
public class ArithmeticExc2 {
        public static void main(String[] args) {
               int d, a;
               try {
                     d = 0;
                     a = 42/d;
                     System. out.println("This will not be printed." );
              }
               catch (ArithmeticException e){
                     System. out.println("Division by zero." );
              }
              System. out.println("After catch statement." );
       }
}
    try块中的对println()的调用时永远不会执行的。一旦异常被引发，程序控制由try块转到catch块。执行永远不会从catch块“返回”到try块。因此，“This will not be printed。"将不会被显示。一旦执行了catch语句，程序控制从整个try/catch机制的下面一行继续。
    一个try和它的catch语句形成一个单元。catch子句的范围限制于try语句前面所定义的语句。一个catch语句不能捕获另一个try声明所引发的异常(除非是嵌套的try语句情况)。被try保护的语句声明必须在一个大括号之内。你不能单独使用try。
    构造catch子句的目的是解决异常情况并且像错误没有发生一样继续运行。